<adapter
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <unique-id>${adapter.unique.id}</unique-id>
  <shared-components>
    <connections>
      <jdbc-pooled-connection>
        <unique-id>LocalMySQL</unique-id>
        <test-statement>SELECT DATABASE(), VERSION(), NOW(), USER();</test-statement>
        <driver-imp>com.mysql.jdbc.Driver</driver-imp>
        <username>${local_db_username}</username>
        <password>${local_db_password}</password>
        <connect-url>${local_db_connect_url}</connect-url>
      </jdbc-pooled-connection>
      <jetty-embedded-connection>
        <unique-id>jetty-connection</unique-id>
      </jetty-embedded-connection>
      <cache-connection>
        <unique-id>soil-type-cache</unique-id>
        <cache-instance class="default-ehcache">
          <cache-name>SoilTypeCache</cache-name>
          <eviction-policy>LRU</eviction-policy>
          <max-elements-in-memory>10</max-elements-in-memory>
        </cache-instance>
      </cache-connection>
    </connections>
  </shared-components>
  <heartbeat-event-interval>
    <unit>MINUTES</unit>
    <interval>60</interval>
  </heartbeat-event-interval>
  <message-error-handler class="standard-processing-exception-handler">
    <processing-exception-service class="service-list">
      <services>
        <exception-report-service>
          <exception-serializer class="exception-as-json-with-stacktrace"/>
        </exception-report-service>
        <embedded-scripting-service>
          <language>javascript</language>
          <script>
            <![CDATA[
                    var objectHeaders = message.getObjectHeaders();
                    var exceptionLocation = objectHeaders["java.lang.Exception_Cause"];
                    if(exceptionLocation != null) {
                      if (exceptionLocation == "VerifyIdentityService(VerifyUsernamePassword)" || exceptionLocation == "ValidateMetadataService(CheckAuthHeader)") {
                        message.addMetadata('httpError', '403');
                      }
                    }
                  ]]>
          </script>
        </embedded-scripting-service>
        <standalone-producer>
          <producer class="jetty-standard-response-producer">
            <status-provider class="http-metadata-status">
              <code-key>httpError</code-key>
            </status-provider>
            <send-payload>true</send-payload>
          </producer>
        </standalone-producer>
      </services>
    </processing-exception-service>
  </message-error-handler>
  <channel-list>
    <channel>
      <auto-start>true</auto-start>
      <unique-id>SoilData</unique-id>
      <consume-connection class="jetty-embedded-connection">
        <unique-id>Embedded Jetty Connection</unique-id>
      </consume-connection>
      <workflow-list>
        <standard-workflow>
          <unique-id>Swagger</unique-id>
          <send-events>false</send-events>
          <consumer class="jetty-message-consumer">
            <unique-id>/lookups/swagger</unique-id>
            <destination class="configured-consume-destination">
              <configured-thread-name>Swagger</configured-thread-name>
              <filter-expression>GET</filter-expression>
              <destination>/lookups/swagger/*</destination>
            </destination>
            <parameter-handler class="jetty-http-parameters-as-metadata"/>
            <header-handler class="jetty-http-ignore-headers"/>
          </consumer>
          <service-collection class="service-list">
            <services>
              <aggregating-fs-consume-service>
                <fs-consumer>
                  <destination class="consume-destination-from-metadata">
                    <default-destination>${swagger.yaml.file}</default-destination>
                  </destination>
                  <delete-aggregated-files>false</delete-aggregated-files>
                  <message-aggregator class="replace-with-first-message-aggregator"/>
                </fs-consumer>
              </aggregating-fs-consume-service>
              <yaml-to-json>
                <source class="string-payload-data-input-parameter"/>
                <target class="string-payload-data-output-parameter"/>
              </yaml-to-json>
              <!-- rewrite the swagger so it has the correct hostname -->
              <json-transform-service>
                <source-json class="string-payload-data-input-parameter"/>
                <target-json class="string-payload-data-output-parameter"/>
                <mapping-spec class="constant-data-input-parameter">
                  <value>[{ "operation": "remove", "spec": {"host": "" }},{"operation": "shift", "spec": { "*": "&amp;","#${adapter.api.hostname}": "host"}}]</value>
                </mapping-spec>
                <metadata-filter class="regex-metadata-filter"/>
              </json-transform-service>
              <standalone-producer>
                <unique-id>SendResponse</unique-id>
                <producer class="jetty-standard-response-producer">
                  <response-header-provider class="jetty-no-response-headers"/>
                  <status-provider class="http-configured-status">
                    <status>OK_200</status>
                  </status-provider>
                  <content-type-provider class="http-configured-content-type-provider">
                    <mime-type>application/json</mime-type>
                  </content-type-provider>
                  <send-payload>true</send-payload>
                </producer>
              </standalone-producer>
            </services>
          </service-collection>
        </standard-workflow>
        <pooling-workflow>
          <unique-id>DoLookup</unique-id>
          <send-events>false</send-events>
          <consumer class="jetty-message-consumer">
            <unique-id>/lookups/soiltype</unique-id>
            <destination class="configured-consume-destination">
              <configured-thread-name>SoiltypeLookup</configured-thread-name>
              <destination>/lookups/soiltype</destination>
            </destination>
            <parameter-handler class="jetty-http-parameters-as-metadata"/>
            <header-handler class="jetty-http-headers-as-metadata"/>
          </consumer>
          <service-collection class="service-list">
            <services>
              <!-- Check the Authorization HEader -->
              <validate-metadata-service>
                <unique-id>CheckAuthHeader</unique-id>
                <required-key>Authorization</required-key>
              </validate-metadata-service>

              <!-- Let's unpick the Auth header
                   We know it comes in as "Basic base64(username:password)"
                -->
              <copy-metadata-service>
                <metadata-keys>
                  <key-value-pair>
                    <key>Authorization</key>
                    <value>__DecodedAuth</value>
                  </key-value-pair>
                </metadata-keys>
              </copy-metadata-service>
              <replace-metadata-value>
                <metadata-key-regexp>__DecodedAuth</metadata-key-regexp>
                <search-value>Basic\s+(.*)$</search-value>
                <replacement-value>$1</replacement-value>
              </replace-metadata-value>
              <metadata-base64-decode>
                <metadata-key-regexp>__DecodedAuth</metadata-key-regexp>
              </metadata-base64-decode>
              <copy-metadata-service>
                <metadata-keys>
                  <key-value-pair>
                    <key>__DecodedAuth</key>
                    <value>requestUser</value>
                  </key-value-pair>
                  <key-value-pair>
                    <key>__DecodedAuth</key>
                    <value>requestPassword</value>
                  </key-value-pair>
                </metadata-keys>
              </copy-metadata-service>
              <replace-metadata-value>
                <metadata-key-regexp>requestUser</metadata-key-regexp>
                <search-value>^(.*):.*$</search-value>
                <replacement-value>$1</replacement-value>
              </replace-metadata-value>
              <replace-metadata-value>
                <metadata-key-regexp>requestPassword</metadata-key-regexp>
                <search-value>^.*:(.*)$</search-value>
                <replacement-value>$1</replacement-value>
              </replace-metadata-value>
              <!-- Now we have the requestUser and requestPassword let's look up the user in the database -->
              <jdbc-data-query-service>
                <connection class="shared-connection">
                  <lookup-name>LocalMySQL</lookup-name>
                </connection>
                <!-- Not Efficient but hey; %message *rules* -->
                <statement-creator class="jdbc-configured-sql-statement">
                  <statement>select db_user, db_password from users where db_user='%message{requestUser}'</statement>
                </statement-creator>
                <result-set-translator class="jdbc-first-row-metadata-translator">
                  <separator></separator>
                  <metadata-key-prefix></metadata-key-prefix>
                </result-set-translator>
              </jdbc-data-query-service>
              <log-message-service/>
              <verify-identity-service>
                <unique-id>VerifyUsernamePassword</unique-id>
                <builder class="metadata-identity-builder">
                  <metadata-key>requestUser</metadata-key>
                  <metadata-key>requestPassword</metadata-key>
                </builder>
                <verifier class="simple-metadata-user-identity-verifier">
                  <metadata-map>
                    <key-value-pair>
                      <key>requestUser</key>
                      <value>db_user</value>
                    </key-value-pair>
                    <key-value-pair>
                      <key>requestPassword</key>
                      <value>db_password</value>
                    </key-value-pair>
                  </metadata-map>
                </verifier>
              </verify-identity-service>
              <trim-metadata-service>
                <metadata-key-regexp>^(lat|lon)$</metadata-key-regexp>
              </trim-metadata-service>
              <validate-metadata-service>
                <required-key>lat</required-key>
                <required-key>lon</required-key>
              </validate-metadata-service>
              <!-- Now we can carry on -->
              <add-formatted-metadata-service>
                <unique-id>GenerateURL</unique-id>
                <format-string>${soiltypes.url}</format-string>
                <argument-metadata-key>lat</argument-metadata-key>
                <argument-metadata-key>lon</argument-metadata-key>
                <metadata-key>soilTypeLookupURL</metadata-key>
              </add-formatted-metadata-service>
              <add-formatted-metadata-service>
                <unique-id>GenerateCacheKey</unique-id>
                <format-string>lat=%1$s&amp;lon=%2$s</format-string>
                <argument-metadata-key>lat</argument-metadata-key>
                <argument-metadata-key>lon</argument-metadata-key>
                <metadata-key>soilTypeKey</metadata-key>
              </add-formatted-metadata-service>
              <branching-service-collection>
                <first-service-id>checkCache</first-service-id>
                <services>
                  <check-cache>
                    <unique-id>checkCache</unique-id>
                    <connection class="shared-connection">
                      <lookup-name>soil-type-cache</lookup-name>
                    </connection>
                    <cache-entry-evaluator>
                      <key-translator class="metadata-cache-value-translator">
                        <metadata-key>soilTypeKey</metadata-key>
                      </key-translator>
                    </cache-entry-evaluator>
                    <keys-not-found-service-id>GetSoilTypeFromRemote</keys-not-found-service-id>
                    <keys-found-service-id>GetSoilTypeFromCache</keys-found-service-id>
                  </check-cache>
                  <service-list>
                    <unique-id>GetSoilTypeFromRemote</unique-id>
                    <services>
                      <!-- Mark it as not from the cache -->
                      <add-metadata-service>
                        <metadata-element>
                          <key>data.from.cache</key>
                          <value>false</value>
                        </metadata-element>
                      </add-metadata-service>
                      <!-- Do the Call -->
                      <standalone-requestor>
                        <producer class="apache-http-producer">
                          <destination class="metadata-destination">
                            <key>soilTypeLookupURL</key>
                          </destination>
                          <method-provider class="http-configured-request-method">
                            <method>GET</method>
                          </method-provider>
                          <response-header-handler class="apache-http-response-headers-as-metadata"/>
                          <ignore-server-response-code>true</ignore-server-response-code>
                        </producer>
                      </standalone-requestor>
                      <!-- Add to the cache -->
                      <add-to-cache>
                        <connection class="shared-connection">
                          <lookup-name>soil-type-cache</lookup-name>
                        </connection>
                        <cache-entry-evaluator>
                          <key-translator class="metadata-cache-value-translator">
                            <metadata-key>soilTypeKey</metadata-key>
                          </key-translator>
                          <value-translator class="string-payload-cache-translator"/>
                        </cache-entry-evaluator>
                      </add-to-cache>
                    </services>
                  </service-list>
                  <service-list>
                    <unique-id>GetSoilTypeFromCache</unique-id>
                    <services>
                      <!-- Add metadata that would be driven from remote request -->
                      <add-metadata-service>
                        <metadata-element>
                          <key>Content-Type</key>
                          <value>application/json</value>
                        </metadata-element>
                        <metadata-element>
                          <key>adphttpresponse</key>
                          <value>200</value>
                        </metadata-element>
                        <metadata-element>
                          <key>data.from.cache</key>
                          <value>true</value>
                        </metadata-element>
                      </add-metadata-service>
                      <!-- Get it from the cache -->
                      <retrieve-from-cache>
                        <connection class="shared-connection">
                          <lookup-name>soil-type-cache</lookup-name>
                        </connection>
                        <cache-entry-evaluator>
                          <key-translator class="metadata-cache-value-translator">
                            <metadata-key>soilTypeKey</metadata-key>
                          </key-translator>
                          <value-translator class="string-payload-cache-translator"/>
                        </cache-entry-evaluator>
                      </retrieve-from-cache>
                    </services>
                  </service-list>
                </services>
              </branching-service-collection>
              <json-transform-service>
                <source-json class="string-payload-data-input-parameter"/>
                <target-json class="string-payload-data-output-parameter"/>
                <mapping-spec class="file-data-input-parameter">
                  <destination class="configured-produce-destination">
                    <destination>${adapter.soiltype.mapping.url}</destination>
                  </destination>
                </mapping-spec>
                <metadata-filter class="regex-metadata-filter"/>
              </json-transform-service>
              <standalone-producer>
                <unique-id>SendResponse</unique-id>
                <producer class="jetty-standard-response-producer">
                  <response-header-provider class="jetty-metadata-response-headers">
                    <filter class="regex-metadata-filter">
                      <include-pattern>Accept-Ranges</include-pattern>
                      <include-pattern>Cache-Control</include-pattern>
                      <include-pattern>Expires</include-pattern>
                      <include-pattern>Last-Modified</include-pattern>
                      <include-pattern>ETag</include-pattern>
                    </filter>
                  </response-header-provider>
                  <status-provider class="http-metadata-status">
                    <code-key>adphttpresponse</code-key>
                  </status-provider>
                  <content-type-provider class="http-metadata-content-type-provider">
                    <metadata-key>Content-Type</metadata-key>
                  </content-type-provider>
                  <send-payload>true</send-payload>
                </producer>
              </standalone-producer>
            </services>
          </service-collection>
        </pooling-workflow>
      </workflow-list>
    </channel>
  </channel-list>
  <message-error-digester class="standard-message-error-digester">
    <digest-max-size>100</digest-max-size>
    <unique-id>ErrorDigest</unique-id>
  </message-error-digester>
</adapter>